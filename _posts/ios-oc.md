---
title: oc 语法 
date: 2017-03-23 23:53:27
tags: 乱弹琴 
---

### 出识OC

OC不是一门全新的语言 
是在C语言的基础上增加了一层最小的面向对象语言 
OC完全兼容C语言语言 可以在OC代码中混入C语言代码,甚至是C++代码 可以使用OC开发Mac OS X平台和iOS平台的应用程序 

OC程序的源文件后缀名为.m 
m代表message代表OC的消息机制
因为OC语言完全兼容C语言，所以在.m文件中可以写C语言的任何代码，甚至C++的代码也可以写在.m文件下。

在OC程序中，main函数仍然是程序的入口和出口 main函数的写法与C语言main函数的写法完全一样。 主函数都是可以带参数和不带参数.

oc 学习路线
![20170323149026441175519.png](http://omoo8c568.bkt.clouddn.com/20170323149026441175519.png)

\#import 指令是C语言中#include指令的增强版 。 

作用: 将指定文件的内容，在预编译的时候，拷贝到写指令的地方。增强: 同一个文件，无论被#import多少次，在预编译的时候只会包含1次。include指令防止重复包含 需要配合预编译执行来实现。
import指令的底层会自动判断这个文件是否被包含,只有没有被包含的时候才会包含。

\#import指令包含的时候可以分为双引号和尖括号.
"" 包含用户自定义; 会先在当前源文件目录下查找如果没有的话再去Xcode去找
<> 包含系统的文件;直接去Xcode编译器中找

我们自己的文件一般都是放在当前源文件目录中，我们自己的文件包含的使用""如果要包含系统的文件<>

关于框架
苹果公司或者第三方事先准备的一些功能模块，把这些功能模块封装在1个1个的类之中。这些类的集合就叫做框架.
类似于C语言中的函数库。它就是一个功能集合，只不过这些功能集合是苹果公司写的，当我们要使用这个功能的时候，就只需要调用就可以了。

Foundation框架: 
提供了OC最基础的功能，Foundation的意思就是基础的意思。 
Foundation头文件的路径。 
/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/ MacOSX10.10.sdk/System/Library/Frameworks/Foundation.framework/Headers 
Foundation.h这个文件中引入了该框架中的所有的头文件，只要引入这个头文件 就可以使用 Foundation框架中所有的功能了。

NSLog 是printf函数的增强版
作用: 向控制台输出数据
用法与printf函数用法基本相同
增强的地方:
A.输出信息之后自动换行
B.在输出指定数据的同时，还会输出一些关于调试的信息。 
会显示出信息的时间: 精确到毫秒 先显示这个信息是由哪个程序输出的。 
NSLog中放的字符串写法与printf中字符串不同

OC中的字符串
在C语言中，字符串常量的写法是用""括起来，代表字符串，而在OC中，是用@"字符串内容"代表字符串。
在OC中字符串终于跟int char等数据类型一样开始有了地位，也有了属于自己的数据类型:“NSString”，所以通过声明NSString的指针变量，即可指向OC中的字符串
NSString*不能指向C语言中的字符串,否则会报错.
NSLog比sprintf多加一个%@占位符,用于输出一个对象

NS前缀
NS来自于NeXTStep的一个软件NeXT Software。NS是为了避免命名冲突而给的前缀。
在Objective-C应用中的所有类名都必须是全局唯一的。由于很多不同的框架中会有一些相似的功能,所以在名字上也可能会有重复(users,views,requests/responses等等),所以苹果官方文档规定类名需要有2-3个字母作为前缀。 

OC中的三种注释
```
1)单行注释:
//我是注释的内容

2)多行注释: 
/*注释内容*/
3)文档注释:
/**
* 传说中的文档注释
*/
```
文档注释的作用
让自己定义的方法(函数)在Xcode输入时弹出示，用来说明此方法(函数)的作用

### 类
 
类的声明在.h文件中,使用@interface @end关键词,  声明成员变量方法(行为);
ps:成员变量的声明在在@interface类名之后的大括号里;

类的实现在.m文件中,用于实现.h中声明的方法和属性, 使用关键字 @implementation @end;

类的定义规范:
1. 类名的每个单词首字母大写;
2. 成员的名字以下划线开头;

创建类的对象的语法:
类名 *对象名 = [类名 new];
类成员变量访问方式
-> 方式访问
```
	Person *p = [Person new];
	p->_age;
```
. 方式访问
```
Person *p = [Person new];
(*p)._age;
```

访问级别
```
@public 全局都可以访问
@protected 只能在类内部和子类中访问(默认)
@private 只能在类内部访问
```

类方法调用 以[] 包裹
有参方法的方法名包括冒号

\#pragma mark 
对代码的分组，方便代码查找和导航用的 

结构体与类的区别 
1. 结构体变量存在栈里面，类实例化出来的对象存在堆里面
2. 结构体里面不能写函数，类里面可以写函数并且可以写方法
3. 结构体成员没有访问权限的说法，类的成员有@public @private @protected三种 
4. 结构体不可以被继承，类可以 
5. 结构体的思想属于面向过程的思维，类是面向对象的产物

函数和对象方法的区别
1. 语法区别，并且对象方法都以-号开头，函数直接以返回值开头
2. 对象方法的声明只能写@interface...@end中间(不包括写成员变量处)、对象方法的实现只能写在@implementation...@end中
3. 函数属于整个文件,可以写在文件中的任何位置,包括@implementation...@end中,但写在@interface...@end会无法识别，函数的声明可以在main函数内部也可以在main函数外部
4. 对象方法只能由对象来调用，不能像函数一样直接调用
5. 对象方法可以访问当前类的成员，函数哪怕写在@implementation里也不可以直接访问

类方法
实例方法就是一个方法,它在类的一个具体实例的范围内执行。也就是说，在你调用一 个实例方法前,你必须首先创建类的一个实例。 
类方法:不需要你创建一个实例。直接用类名就可以调用，不依赖于对象。 
+ 表示类方法,就是类调用方法。 
- 表示是实例(对象)方法,只能是对象可调用,依赖与任何对象的方法。

类方法使用注意事项 
1)类方法可以和实例方法同名,这个并不影响使用;
2)类方法和实例方法一样在@interface里声明,在@implementation里实现。 
3)类方法只能被类调用执行,向实例对象发送类方法是不能被触发执行的。 
4)类方法里面不能直接使用实例成员 
5)类方法里面可以调用其他类方法，打不可以直接调用对象方法 
6)对象方法里面可以调用类方法

匿名对象
简单来说就是没有用指针变量指向的对象叫匿名对象 
优点:可以简化代码,方便方法调用 
缺点:匿名对象实例化以后,只能正确的使用成员变量一次 

OC中方法不能重载 
方法重载是指在一个类中定义多个同名的方法,但要求每个方法具有不同的参数的 类型或参数的个数。调用重载方法时,其他语言(Java、c++)编译器能通过检查调用的方 法的参数类型和 个数选择一个恰当的方法。方法重载通常用于创建完成一组任务相似 但参数的类型或参数的个数 不同的方法 

static关键字
OC中与C语言的static关键字功能一样。 但是OC中static不能修饰成员变量，也不能修饰方法! 

基类和派生类之间的关系 
1. 基类的私有属性能被继承,不能被使用。 
2. OC中的继承是单继承
3. 继承的合理性 


方法的重写 
从父类继承的方法,可能这个方法并不适合子类,然后子类在不改方法名的前 下，只是修改方法里面具体的实现，就称之为方法的重写。

继承的注意事项 
1. 子类不能定义和父类同名的变量,但是可以继承父类的变量 
2. OC类都是单继承，不支持多重继承 
3. OC类支持被继承多个类(多派生) 
4. OC类的继承有传递性:即原始基类里定义的属性和方法，在子类的子类中也会被继承过 去 

继承体系中方法调用的顺序 
1. 在自己类中找
2. 如果没有,去父类中找 
3. 如果父类中没有,就去父类的父类中 
4. 如果父类的父类也没有,就还往上找,直到找到基类(NSObject) 
5. 如果NSObject也没有就报错了

OC中的私有变量 
在类的实现即.m @implementation中也可以声明成员变量,但是因为在其他文件中通常都==只是包含头文件而不会包含实现文件==,所以在.m文件中声明的成员变量是@private的。在.m中 定义的成员变量不能和它的头文件.h中的成员变量同名,在这期间使用@public等关键字也是 徒劳的。 

OC中私有方法实现有两种方式: 
1. 方法在.m中实现,不在.h中声明(相对私有) 
2. 通过匿名类别(延展)实现私有(一般意义上的私有) 

description 方法:
1. 类似于java toString(), 在NSLog(@"%@", obj) 中返回对象的描述信息;
2. 千万不要在对象description方法中同时使用%@和self ,否则会死循环;

类的本质 
类的本质其实也是一个对象(类类型(class)的对象) 
类对象: 
* 类对象在程序运行时一直存在。 
* 类对象是一种数据结构,存储类的基本信息:类大小,类名称,类的版本以及消息与函数 的映射表等 
* 类对象所保存的信息在程序编译时确定,在第一次运行程序的时候被加载到内存中。 
* 类对象代表类,class代表类对象,类方法属于类对象 
* 如果消息的接收者是类名,则类名代表类对象 
* 运行时,所有类的实例都由类对象生成,类对象会把实例的isa的值修改成自己的地址, 每 个实例的isa都指向该实例的类对象, 
* 从类对象里可以知道父类信息、可以响应的方法等 *类对象只能使用类方法,不能用实例方法 
类对象的获取 
* 通过实例对象获取

```
Dog *dog = [Dog new]; 
Dog *d2 = [Dog new]; 
//第一种方法获取类对象 
Class c = [dog class]; 
Class c2 = [d2 class]; 

```

* 通过类名获取 ,类名就是类对象 

类对象作用:
* 用来调用类方法 
* 实例化实例对象 

SEL类型:
全称selector, 用于表示方法的数据类型;
SEL类型作用: 
1. 可以定义变量 
2. 可以用来作为方法的形参 
3. 可以用来作为方法的实参

Objetive-C中的Method结构 
```
struct objc_method{
	SEL method_name;//方法名
	char *method_types; //方法参数类型 IMP 
	method_imp; //方法地址(IMP) 
};
typedefobjc_method Method;

```
什么是IMP
– IMP是”implementation”的缩写,它是objetive-C方法(method)实现代码块的地址,类似函数指针,通过它可以直接访问任意一个方法。免去发送消息的代价。
获取方法的IMP
```
-(IMP)methodForSelector:(SEL)aSelector;

SEL print_sel =NSSelectorFromString(@“print:”);//获得SEL
IMP imp=[person methodForSelector:print_sel];//得到IMP 
imp(person,print_sel,@“*********”);//通过IMP直接调用方法等效调用:[person print_sel:@“*********”];
– imp的第一参数是对象自己(self),第二参数是方法标示,第三个是方法的参数
```

@class 简单的引入一个类
并不会包含类的所有内容
@class 相当于引入一个占位符, 告诉编译器这是一个类, 按照一般类来使用就可以了,不用关心这个类里面的内容;
这样有两个优点:
1. 快,编译过程快;
2. 避免嵌套包含,因为已经告诉编译器了,不要管内部情况是怎样的,只管按照一个类名编译过去就可以了;

@autoreleasepool和@autorelease
@autoreleasepool是一个自动释放池, 用于自动释放(仅一次)池中的对象;
@autorelease ,将对象放入 自动释放池;

分类(Category)的作用:
1. 将1个类中的不同方法分到多个不同的文件中存储，便于对类进行模块化设计和团队开发。
2. 可以在不修改原来类的基础上，为这个类扩充一些方法。
3. 注意：
	* 分类中只能增加“方法”，不能增加成员变量。
	* 分类中可以访问原来类中的成员变量。

分类的使用流程
* 声明分类-->实现分类-->使用分类
* 分类的命名规则:类名+扩展方法, 如“NSString+countNum”。 
* 分类的接口声明与类的定义十分相似,但分类不继承父类,只需要带有一个括号,表明该分类的主要用途。

声明和实现一个分类
在.h文件中,声明分类:
```
@interface 类名 (分类名)
//方法;
@end

```
在.m文件中(也可以在.h中实现),实现分类
```
@implementation ClassName(CategoryName) NewMethod
{
// 方法实现
}
@end

```

匿名分类/ 类扩展
```
@interface MyClass ()
{
   //类扩展 float value;
}
- (void)setValue:(float)newValue;
@end

```

分类的一个特例
其名字为匿名(为空),并且新添加的方法一定要予以实现。(Category没有这个限制)
为本类扩充一些私有的成员变量和私有方法。

分类和类扩展的区别：
1. 类别中只能增加方法;
2. 类扩展不仅可以增加方法,还可以增加实例变量(或者合成属性),只是该实例变量默认是私有类型的(作用范围只能在自身类,而不是子类或其他地方);
3. 类扩展中声明的方法没被实现,编译器会报警,但是类别中的方法没被实现编译器是不会有任何警告的。这是因为类扩展是在编译阶段被添加到类中,而类别是在运行时添加到类中。
4. 类扩展不能像类别那样拥有独立的实现部分(@implementation部分),也就是说,类扩展所声明的方法必须依托对应类的实现部分来实现。
5. 定义在 .m 文件中的类扩展方法为私有的,定义在 .h 文件(头文件)中的类扩展方法为公有 的。类扩展是在 .m 文件中声明私有方法的非常好的方式。

block的作用
用来保存一段代码，可以在恰当的时间再取出来调用.
语法
```
void (^block名称)(参数列表) = ^(参数列表){
// 代码实现；
}
```

定义一个block 并使用
```
typedef int(^MyBlock)(int,int);

MyBlock minusBlock = ^(int num1,int num2){
return num1 - num2;
};

```

Protocol
1. 类似于java 中的接口

```
@protocol 协议名称
// 各种方法；
@end

@interface 类名 : NSObject <协议名1，协议名2，...>
@end

```

@required和@optional
@required：用@required修饰的方法，必须实现。
@optional：用@optional修饰的方法，可实现，可不实现。
@required 和 @optional的主要意义:一般用于序员交流用。

protocol类型限制
```
要求：变量d指向的对象必须遵守PlayProtocol协议
id<PlayProtocol> d = [[Person alloc] init];

要求：要求Person创建出来的对象，必须遵守PlayProtocol协议。
Person < PlayProtocol > *p = [[Person alloc] init];
```

id和instancetype的区别
1. instancetype只能作为函数或者方法的返回值
2. id能作为方法或者参数的数据类型、返回值，也能用来定义变量。
3. instancetype能精确的限制返回值的具体类型。

## 后记

涉及了oc 大部分语法相关的概念. 未介绍到的包括内存管理 和 KVC/ KVO;

我认为内存管理是任何一门语言不可避免也是最精华的内容,其他的都是概念,在学习编译器给我们定下的约定, 准守这些约定是记忆的问题, 查就可以了. 而内存管理是编译器不能帮我们解决的 具体的逻辑问题. 不管什么语言, 什么内存管理策略, 逻辑是守恒的,不会因为选择的语言不通而不通.

对于内存管理和 KVC/KVO 等后续补上

